<?xml version="1.0" encoding="UTF-8"?>
<action-sequence> 
  <title>Dados</title>
  <version>1</version>
  <logging-level>ERROR</logging-level>
  <documentation> 
    <author>Rpassos</author>  
    <description>MDX Query to JSON</description>  
    <help/>  
    <result-type/>  
    <icon/> 
  </documentation>

  <inputs> 
    <callback type="string"> 
      <sources> 
        <request>callback</request> 
      </sources>  
      <default-value/> 
    </callback>  
    <getData type="string"> 
      <sources> 
        <request>getData</request> 
      </sources>  
      <default-value><![CDATA[1]]></default-value> 
    </getData>  
    <Ano type="string"> 
      <sources> 
        <request>Ano</request> 
      </sources>  
      <default-value><![CDATA[2001]]></default-value> 
    </Ano>  
    <Cedente type="string"> 
      <sources> 
        <request>Cedente</request> 
      </sources>  
      <default-value><![CDATA['xx']]></default-value> 
    </Cedente>  
    <Mes type="string"> 
      <sources> 
        <request>Mes</request> 
      </sources>  
      <default-value><![CDATA['xx']]></default-value> 
    </Mes>  
    <Sacado type="string"> 
      <sources> 
        <request>Sacado</request> 
      </sources>  
      <default-value><![CDATA['xx']]></default-value> 
    </Sacado>  
    <Gerente type="string"> 
      <sources> 
        <request>Gerente</request> 
      </sources>  
      <default-value><![CDATA['xx']]></default-value> 
    </Gerente> 
  </inputs>

  <outputs> 
    <out type="string"> 
      <destinations> 
        <response>content</response> 
      </destinations> 
    </out>  
    <json_done type="string"> 
      <destinations> 
        <response>content</response> 
      </destinations> 
    </json_done> 
  </outputs>

  <resources> 
    <catalog>
	<solution-file>
        <catalog>Operacoes de Credito</catalog>     
        <mime-type>text/plain</mime-type>
      </solution-file>
    </catalog> 
  </resources>
  
  <!-- Mapeamento dos parametros-->  
  <!-- variaveis de saida-->  
  <!-- Schemas XML-->  
  <actions> 
    <!-- ***************************Top 5 sacados*************** -->  
    <actions> 
      <condition><![CDATA[getData == "Top5Sacados"]]></condition>  
      <action-definition> 
        <component-name>MDXLookupRule</component-name>
        <action-type>OLAP</action-type>
        <action-inputs> 
          <Cedente type="string"/> 
        </action-inputs>
        <action-resources> 
          <catalog mapping="catalog"/> 
        </action-resources>
        <action-outputs> 
          <query-results type="result-set" mapping="query_result"/> 
        </action-outputs>
        <component-definition> 
          <jndi><![CDATA[dw_wba_fi]]></jndi>  
          <catalog>Operacoes de Credito</catalog>   
          <query><![CDATA[
		    with member [Measures].[Em Aberto] as 'Sum({[Situacao do Pagamento].[Em aberto]}, [Measures].[Valor do Titulo])'
			  member [Measures].[Valor Total] as 'Sum({Ancestor([Sacado].CurrentMember, 1.0)}, [Measures].[Em Aberto])'
			  member [Measures].[%] as '([Measures].[Em Aberto] / [Measures].[Valor Total])', format_string = "#0.00%"
			  member [Measures].[Total Top 10] as 'Sum(TopCount(Order({[Sacado].[Total].Children}, [Measures].[Em Aberto], DESC), 10.0), [Measures].[Em Aberto])'
			  member [Measures].[% Top 10] as 'Sum(TopCount(Order({[Sacado].[Total].Children}, [Measures].[Em Aberto], DESC), 10.0), [Measures].[%])', format_string = "#0.00%"
			  member [Measures].[A Vencer] as 'Sum({[Situacao do Pagamento].[Em aberto].[Em aberto   A Vencer]}, [Measures].[Valor do Titulo])'
			  member [Measures].[Vencido] as 'Sum({[Situacao do Pagamento].[Em aberto].[Em aberto   Vencido]}, [Measures].[Valor do Titulo])'
			select NON EMPTY {[Measures].[Em Aberto]} ON COLUMNS,
			  NON EMPTY Union({[Sacado].[Total]}, TopCount(Order({[Sacado].[Total].Children}, [Measures].[Em Aberto], DESC), 10.0)) ON ROWS
			from [Operacoes de Credito]
			where Crossjoin(Crossjoin({[Cedente].[{Cedente}]}, {[Operacoes.Operacoes : Codigo].[Titulos].[040], [Operacoes.Operacoes : Codigo].[Titulos].[041], [Operacoes.Operacoes : Codigo].[Titulos].[046]}), {[Produto].[Propria]})
			
]]></query> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>JavascriptRule</component-name>
        <action-type>JavaScript</action-type>
        <action-inputs> 
          <query_result type="result-set"/>  
          <callback type="string"/> 
        </action-inputs>
        <action-outputs> 
          <json type="string"/>  
          <rowCount type="integer"/> 
        </action-outputs>
        <component-definition> 
  <script><![CDATA[
QL = ''; 
DEBUG=false;

function formataJSON(v) {
var s = null;
if (v == null) {
s = 'null';
} else if (v instanceof java.lang.String) {
s = '"' + v + '"';
} else if (v instanceof java.util.Date) {
s = /*"new Date(" +*/ v.getTime() /*+ ")"*/;
} else if (v instanceof Array) {
s = new java.lang.StringBuilder("[ ");
for (var i=0; i<v.length; i++) {
if (i>0) {
s.append(',');
}
s.append(formataJSON(v[i]));
}
s.append(" ]");
} else {
s = v.toString();
}
if (DEBUG) {
 s = s.toString() + " /* " + v.getClass().getName() + " */";
}
return s.toString();
}

var rowCount=query_result.getRowCount();
var colCount=query_result.getColumnCount();
var json=new java.lang.StringBuilder('{ "result" : {');

var columnHeaders = new Array();
columnHeaders[0] = '"metrica"';
for (var col=0; col<colCount; col++) {
columnHeaders[col+1] = query_result.getMetaData().getColumnHeaders()[0][col];
}

json.append( 
'"metadata": { ' +
'"columns": ' + formataJSON(columnHeaders) + ', ' + QL +
'"rows": ' + rowCount + ', ' + QL +
'"cols": ' + (colCount+1) + QL +
' },' + QL);


json.append('"data" : [ ');
var rowData = null;
while (rowData = query_result.nextFlattened()) {
json.append(QL).append(formataJSON(rowData));
json.append(',');
}
json.deleteCharAt(json.length()-1); 

json.append(QL + '] ' + QL);

json.append('}' + QL + '}');

if (callback !== '' || callback === null) {
json = callback + '(' + json.toString() + ')'
} else {
json = json.toString();
}]]></script> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>TemplateComponent</component-name>
        <action-type>Message Template</action-type>
        <action-inputs> 
          <json type="string"/> 
        </action-inputs>
        <action-outputs> 
          <output-message type="string" mapping="out"/> 
        </action-outputs>
        <component-definition> 
          <template><![CDATA[{json}]]></template> 
        </component-definition> 
      </action-definition>
 
    </actions> 
	
	<!-- ***************************Patrimonio*************** -->  
    <actions> 
      <condition><![CDATA[getData == "Patrimonio"]]></condition>  
      <action-definition> 
        <component-name>MDXLookupRule</component-name>
        <action-type>OLAP</action-type>
        <action-inputs> 
          <Ano type="string"/> 
        </action-inputs>
        <action-resources> 
          <catalog mapping="catalog"/> 
        </action-resources>
        <action-outputs> 
          <query-results type="result-set" mapping="query_result"/> 
        </action-outputs>
        <component-definition> 
          <jndi><![CDATA[dw_wba_fi]]></jndi>  
          <catalog>Operacoes de Credito</catalog>   
          <query><![CDATA[
			
			SELECT
			NON EMPTY {Hierarchize({{[Data Inc Contabil.AnoMesDia].[2016]}, Filter({{[Data Inc Contabil.AnoMesDia].[Mes].Members}}, (Exists(Ancestor([Data Inc Contabil.AnoMesDia].CurrentMember, [Data Inc Contabil.AnoMesDia].[Ano]), {[Data Inc Contabil.AnoMesDia].[2016]}).Count  > 0))})} ON COLUMNS,
			NON EMPTY CrossJoin([Empresa].[Razao Social].Members, {[Measures].[Valor Patrimonio Mes]}) ON ROWS
			FROM [Operacoes de Credito]
			WHERE Hierarchize(Union(CrossJoin({[Produto].[Propria]}, {[Operacoes.Operacoes : Codigo].[Titulos].[040]}), Union(CrossJoin({[Produto].[Propria]}, {[Operacoes.Operacoes : Codigo].[Titulos].[041]}), CrossJoin({[Produto].[Propria]}, {[Operacoes.Operacoes : Codigo].[Titulos].[046]}))))

]]></query> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>JavascriptRule</component-name>
        <action-type>JavaScript</action-type>
        <action-inputs> 
          <query_result type="result-set"/>  
          <callback type="string"/> 
        </action-inputs>
        <action-outputs> 
          <json type="string"/>  
          <rowCount type="integer"/> 
        </action-outputs>
        <component-definition> 
  <script><![CDATA[
QL = ''; 
DEBUG=false;

function formataJSON(v) {
var s = null;
if (v == null) {
s = 'null';
} else if (v instanceof java.lang.String) {
s = '"' + v + '"';
} else if (v instanceof java.util.Date) {
s = /*"new Date(" +*/ v.getTime() /*+ ")"*/;
} else if (v instanceof Array) {
s = new java.lang.StringBuilder("[ ");
for (var i=0; i<v.length; i++) {
if (i>0) {
s.append(',');
}
s.append(formataJSON(v[i]));
}
s.append(" ]");
} else {
s = v.toString();
}
if (DEBUG) {
 s = s.toString() + " /* " + v.getClass().getName() + " */";
}
return s.toString();
}

var rowCount=query_result.getRowCount();
var colCount=query_result.getColumnCount();
var json=new java.lang.StringBuilder('{ "result" : {');

var columnHeaders = new Array();
columnHeaders[0] = '"metrica"';
for (var col=0; col<colCount; col++) {
columnHeaders[col+1] = query_result.getMetaData().getColumnHeaders()[0][col];
}

json.append( 
'"metadata": { ' +
'"columns": ' + formataJSON(columnHeaders) + ', ' + QL +
'"rows": ' + rowCount + ', ' + QL +
'"cols": ' + (colCount+1) + QL +
' },' + QL);


json.append('"data" : [ ');
var rowData = null;
while (rowData = query_result.nextFlattened()) {
json.append(QL).append(formataJSON(rowData));
json.append(',');
}
json.deleteCharAt(json.length()-1); 

json.append(QL + '] ' + QL);

json.append('}' + QL + '}');

if (callback !== '' || callback === null) {
json = callback + '(' + json.toString() + ')'
} else {
json = json.toString();
}]]></script> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>TemplateComponent</component-name>
        <action-type>Message Template</action-type>
        <action-inputs> 
          <json type="string"/> 
        </action-inputs>
        <action-outputs> 
          <output-message type="string" mapping="out"/> 
        </action-outputs>
        <component-definition> 
          <template><![CDATA[{json}]]></template> 
        </component-definition> 
      </action-definition>
 
    </actions>
  
    <!-- ***************************Liquidez*************** -->  
    <actions> 
      <condition><![CDATA[getData == "Liquidez"]]></condition>  
      <action-definition> 
        <component-name>MDXLookupRule</component-name>
        <action-type>OLAP</action-type>
        <action-inputs> 
          <Ano type="string"/> 
        </action-inputs>
        <action-resources> 
          <catalog mapping="catalog"/> 
        </action-resources>
        <action-outputs> 
          <query-results type="result-set" mapping="query_result"/> 
        </action-outputs>
        <component-definition> 
          <jndi><![CDATA[dw_wba_fi]]></jndi>  
          <catalog>Operacoes de Credito</catalog>   
          <query><![CDATA[
with set [Regressado] as 'Except({[Comportamento de Pagamento].[Total].Children}, {[Comportamento de Pagamento].[Regressado]})'
  member [Measures].[Valor Regressado] as '([Comportamento de Pagamento].[Regressado], [Measures].[Valor do Titulo])'
  member [Measures].[Valor Pontual_Aux] as '([Faixa Pagamento].[Pontual], [Measures].[Valor do Titulo])'
  member [Measures].[Valor Pontual] as 'Sum([Regressado], [Measures].[Valor Pontual_Aux])'
  member [Measures].[Valor Ate 5 dias_Aux] as '([Faixa Pagamento].[Ate 5 dias], [Measures].[Valor do Titulo])'
  member [Measures].[Valor Ate 5 dias] as 'Sum([Regressado], [Measures].[Valor Ate 5 dias_Aux])'
  member [Measures].[Valor De 6 a 15 dias_Aux] as '([Faixa Pagamento].[De 6 a 15 dias], [Measures].[Valor do Titulo])'
  member [Measures].[Valor De 6 a 15 dias] as 'Sum([Regressado], [Measures].[Valor De 6 a 15 dias_Aux])'
  member [Measures].[Valor De 16 a 30 dias_Aux] as '([Faixa Pagamento].[De 16 a 30 dias], [Measures].[Valor do Titulo])'
  member [Measures].[Valor De 16 a 30 dias] as 'Sum([Regressado], [Measures].[Valor De 16 a 30 dias_Aux])'
  member [Measures].[Valor De 31 a 60 dias_Aux] as '([Faixa Pagamento].[De 31 a 60 dias], [Measures].[Valor do Titulo])'
  member [Measures].[Valor De 31 a 60 dias] as 'Sum([Regressado], [Measures].[Valor De 31 a 60 dias_Aux])'
  member [Measures].[Valor De > 60 dias_Aux] as '([Faixa Pagamento].[De > 60 dias], [Measures].[Valor do Titulo])'
  member [Measures].[Valor De > 60 dias] as 'Sum([Regressado], [Measures].[Valor De > 60 dias_Aux])'
  member [Measures].[Valor Vencidos] as '([Situacao do Pagamento].[Em aberto].[Em aberto   Vencido], [Measures].[Valor do Titulo])'
  member [Measures].[Valor Total Vencimento] as '((((((([Measures].[Valor Regressado] + [Measures].[Valor Pontual]) + [Measures].[Valor Ate 5 dias]) + [Measures].[Valor De 6 a 15 dias]) + [Measures].[Valor De 16 a 30 dias]) + [Measures].[Valor De 31 a 60 dias]) + [Measures].[Valor De > 60 dias]) + [Measures].[Valor Vencidos])'
  member [Measures].[Regressado] as '([Measures].[Valor Regressado] / [Measures].[Valor Total Vencimento])', format_string = "#0.00%"
  member [Measures].[Pontual] as '([Measures].[Valor Pontual] / [Measures].[Valor Total Vencimento])', format_string = "#0.00%"
  member [Measures].[Ate 5 dias] as '([Measures].[Valor Ate 5 dias] / [Measures].[Valor Total Vencimento])', format_string = "#0.00%"
  member [Measures].[De 6 a 15 dias] as '([Measures].[Valor De 6 a 15 dias] / [Measures].[Valor Total Vencimento])', format_string = "#0.00%"
  member [Measures].[De 16 a 30 dias] as '([Measures].[Valor De 16 a 30 dias] / [Measures].[Valor Total Vencimento])', format_string = "#0.00%"
  member [Measures].[De 31 a 60 dias] as '([Measures].[Valor De 31 a 60 dias] / [Measures].[Valor Total Vencimento])', format_string = "#0.00%"
  member [Measures].[De > 60 dias] as '([Measures].[Valor De > 60 dias] / [Measures].[Valor Total Vencimento])', format_string = "#0.00%"
  member [Measures].[Vencidos] as '([Measures].[Valor Vencidos] / [Measures].[Valor Total Vencimento])', format_string = "#0.00%"
select NON EMPTY {[Measures].[Valor Total Vencimento], [Measures].[Pontual], [Measures].[Ate 5 dias], [Measures].[De 6 a 15 dias], [Measures].[De 16 a 30 dias], [Measures].[De 31 a 60 dias], [Measures].[De > 60 dias], [Measures].[Regressado], [Measures].[Vencidos]} ON COLUMNS,
  NON EMPTY Hierarchize(Union(Union({([Data Vencimento.AnoMes].[Setembro-2013] : [Data Vencimento.AnoMes].[Setembro-2016])}, {[Data Vencimento.AnoMes].[Setembro-2013]}), {[Data Vencimento.AnoMes].[Setembro-2016]})) ON ROWS
from [Operacoes de Credito]
where Crossjoin(Crossjoin({[Empresa].[CONSOLIDADO].[PRUDENT FUNDO DE INVESTIMENTO EM DIREITOS CREDITORIOS]}, {[Operacoes.Operacoes : Codigo].[Titulos].[040], [Operacoes.Operacoes : Codigo].[Titulos].[041], [Operacoes.Operacoes : Codigo].[Titulos].[046]}), {[Produto].[Propria]})

]]></query> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>JavascriptRule</component-name>
        <action-type>JavaScript</action-type>
        <action-inputs> 
          <query_result type="result-set"/>  
          <callback type="string"/> 
        </action-inputs>
        <action-outputs> 
          <json type="string"/>  
          <rowCount type="integer"/> 
        </action-outputs>
        <component-definition> 
  <script><![CDATA[
QL = ''; 
DEBUG=false;

function formataJSON(v) {
var s = null;
if (v == null) {
s = 'null';
} else if (v instanceof java.lang.String) {
s = '"' + v + '"';
} else if (v instanceof java.util.Date) {
s = /*"new Date(" +*/ v.getTime() /*+ ")"*/;
} else if (v instanceof Array) {
s = new java.lang.StringBuilder("[ ");
for (var i=0; i<v.length; i++) {
if (i>0) {
s.append(',');
}
s.append(formataJSON(v[i]));
}
s.append(" ]");
} else {
s = v.toString();
}
if (DEBUG) {
 s = s.toString() + " /* " + v.getClass().getName() + " */";
}
return s.toString();
}

var rowCount=query_result.getRowCount();
var colCount=query_result.getColumnCount();
var json=new java.lang.StringBuilder('{ "result" : {');

var columnHeaders = new Array();
columnHeaders[0] = '"metrica"';
for (var col=0; col<colCount; col++) {
columnHeaders[col+1] = query_result.getMetaData().getColumnHeaders()[0][col];
}

json.append( 
'"metadata": { ' +
'"columns": ' + formataJSON(columnHeaders) + ', ' + QL +
'"rows": ' + rowCount + ', ' + QL +
'"cols": ' + (colCount+1) + QL +
' },' + QL);


json.append('"data" : [ ');
var rowData = null;
while (rowData = query_result.nextFlattened()) {
json.append(QL).append(formataJSON(rowData));
json.append(',');
}
json.deleteCharAt(json.length()-1); 

json.append(QL + '] ' + QL);

json.append('}' + QL + '}');

if (callback !== '' || callback === null) {
json = callback + '(' + json.toString() + ')'
} else {
json = json.toString();
}]]></script> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>TemplateComponent</component-name>
        <action-type>Message Template</action-type>
        <action-inputs> 
          <json type="string"/> 
        </action-inputs>
        <action-outputs> 
          <output-message type="string" mapping="out"/> 
        </action-outputs>
        <component-definition> 
          <template><![CDATA[{json}]]></template> 
        </component-definition> 
      </action-definition>
 
    </actions>

<!-- ***************************Atraso*************** -->  
    <actions> 
      <condition><![CDATA[getData == "Atraso"]]></condition>  
      <action-definition> 
        <component-name>MDXLookupRule</component-name>
        <action-type>OLAP</action-type>
        <action-inputs> 
          <Ano type="string"/> 
        </action-inputs>
        <action-resources> 
          <catalog mapping="catalog"/> 
        </action-resources>
        <action-outputs> 
          <query-results type="result-set" mapping="query_result"/> 
        </action-outputs>
        <component-definition> 
          <jndi><![CDATA[dw_wba_fi]]></jndi>  
          <catalog>Operacoes de Credito</catalog>   
          <query><![CDATA[
with member [Measures].[Valor Pontual] as '([Faixa Vencimento].[Pontual], [Measures].[Valor do Titulo])'
  member [Measures].[Valor Ate 5 dias] as '([Faixa Vencimento].[Ate 5 dias], [Measures].[Valor do Titulo])'
  member [Measures].[Valor De 6 a 15 dias] as '([Faixa Vencimento].[De 6 a 15 dias], [Measures].[Valor do Titulo])'
  member [Measures].[Valor De 16 a 30 dias] as '([Faixa Vencimento].[De 16 a 30 dias], [Measures].[Valor do Titulo])'
  member [Measures].[Valor De 31 a 60 dias] as '([Faixa Vencimento].[De 31 a 60 dias], [Measures].[Valor do Titulo])'
  member [Measures].[Valor De > 60 dias] as '([Faixa Vencimento].[De > 60 dias], [Measures].[Valor do Titulo])'
  member [Measures].[Valor Total Em Atraso] as '(((([Measures].[Valor Ate 5 dias] + [Measures].[Valor De 6 a 15 dias]) + [Measures].[Valor De 16 a 30 dias]) + [Measures].[Valor De 31 a 60 dias]) + [Measures].[Valor De > 60 dias])'
  member [Measures].[Ate 5 dias] as '([Measures].[Valor Ate 5 dias] / [Measures].[Valor Total Em Atraso])', format_string = "#0.00%"
  member [Measures].[De 6 a 15 dias] as '([Measures].[Valor De 6 a 15 dias] / [Measures].[Valor Total Em Atraso])', format_string = "#0.00%"
  member [Measures].[De 16 a 30 dias] as '([Measures].[Valor De 16 a 30 dias] / [Measures].[Valor Total Em Atraso])', format_string = "#0.00%"
  member [Measures].[De 31 a 60 dias] as '([Measures].[Valor De 31 a 60 dias] / [Measures].[Valor Total Em Atraso])', format_string = "#0.00%"
  member [Measures].[De > 60 dias] as '([Measures].[Valor De > 60 dias] / [Measures].[Valor Total Em Atraso])', format_string = "#0.00%"
select {[Measures].[Valor Total Em Atraso], [Measures].[Ate 5 dias], [Measures].[De 6 a 15 dias], [Measures].[De 16 a 30 dias], [Measures].[De 31 a 60 dias], [Measures].[De > 60 dias]} ON COLUMNS,
  NON EMPTY Hierarchize({[Data Vencimento.AnoMesDia].[Total], [Data Vencimento.AnoMesDia].[2015], [Data Vencimento.AnoMesDia].[2016]}) ON ROWS
from [Operacoes de Credito]
where Crossjoin(Crossjoin(Crossjoin({[Empresa].[CONSOLIDADO].[PRUDENT FUNDO DE INVESTIMENTO EM DIREITOS CREDITORIOS]}, {[Operacoes.Operacoes : Codigo].[Titulos].[040], [Operacoes.Operacoes : Codigo].[Titulos].[041], [Operacoes.Operacoes : Codigo].[Titulos].[046]}), {[Produto].[Propria]}), {[Situacao do Pagamento].[Em aberto].[Em aberto   Vencido]})

]]></query> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>JavascriptRule</component-name>
        <action-type>JavaScript</action-type>
        <action-inputs> 
          <query_result type="result-set"/>  
          <callback type="string"/> 
        </action-inputs>
        <action-outputs> 
          <json type="string"/>  
          <rowCount type="integer"/> 
        </action-outputs>
        <component-definition> 
  <script><![CDATA[
QL = ''; 
DEBUG=false;

function formataJSON(v) {
var s = null;
if (v == null) {
s = 'null';
} else if (v instanceof java.lang.String) {
s = '"' + v + '"';
} else if (v instanceof java.util.Date) {
s = /*"new Date(" +*/ v.getTime() /*+ ")"*/;
} else if (v instanceof Array) {
s = new java.lang.StringBuilder("[ ");
for (var i=0; i<v.length; i++) {
if (i>0) {
s.append(',');
}
s.append(formataJSON(v[i]));
}
s.append(" ]");
} else {
s = v.toString();
}
if (DEBUG) {
 s = s.toString() + " /* " + v.getClass().getName() + " */";
}
return s.toString();
}

var rowCount=query_result.getRowCount();
var colCount=query_result.getColumnCount();
var json=new java.lang.StringBuilder('{ "result" : {');

var columnHeaders = new Array();
columnHeaders[0] = '"metrica"';
for (var col=0; col<colCount; col++) {
columnHeaders[col+1] = query_result.getMetaData().getColumnHeaders()[0][col];
}

json.append( 
'"metadata": { ' +
'"columns": ' + formataJSON(columnHeaders) + ', ' + QL +
'"rows": ' + rowCount + ', ' + QL +
'"cols": ' + (colCount+1) + QL +
' },' + QL);


json.append('"data" : [ ');
var rowData = null;
while (rowData = query_result.nextFlattened()) {
json.append(QL).append(formataJSON(rowData));
json.append(',');
}
json.deleteCharAt(json.length()-1); 

json.append(QL + '] ' + QL);

json.append('}' + QL + '}');

if (callback !== '' || callback === null) {
json = callback + '(' + json.toString() + ')'
} else {
json = json.toString();
}]]></script> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>TemplateComponent</component-name>
        <action-type>Message Template</action-type>
        <action-inputs> 
          <json type="string"/> 
        </action-inputs>
        <action-outputs> 
          <output-message type="string" mapping="out"/> 
        </action-outputs>
        <component-definition> 
          <template><![CDATA[{json}]]></template> 
        </component-definition> 
      </action-definition>
 
    </actions>


<!-- ***************************PDD*************** -->  
    <actions> 
      <condition><![CDATA[getData == "PDD"]]></condition>  
      <action-definition> 
        <component-name>MDXLookupRule</component-name>
        <action-type>OLAP</action-type>
        <action-inputs> 
          <Ano type="string"/> 
        </action-inputs>
        <action-resources> 
          <catalog mapping="catalog"/> 
        </action-resources>
        <action-outputs> 
          <query-results type="result-set" mapping="query_result"/> 
        </action-outputs>
        <component-definition> 
          <jndi><![CDATA[dw_wba_fi]]></jndi>  
          <catalog>Operacoes de Credito</catalog>   
          <query><![CDATA[
with member [Measures].[Comissaria] as '([Operacoes.Operacoes : Codigo].[Titulos].[046], [Measures].[Valor do Titulo])'
  member [Measures].[Cheques] as '([Operacoes.Operacoes : Codigo].[Titulos].[041], [Measures].[Valor do Titulo])'
  member [Measures].[Titulos] as '([Operacoes.Operacoes : Codigo].[Titulos].[040], [Measures].[Valor do Titulo])'
  member [Measures].[Fomento] as '([Operacoes.Operacoes : Codigo].[Outros].[053], [Measures].[Valor do Titulo])'
  member [Measures].[Total] as '((([Measures].[Comissaria] + [Measures].[Cheques]) + [Measures].[Titulos]) + [Measures].[Fomento])'
select NON EMPTY {[Measures].[Comissaria], [Measures].[Fomento], [Measures].[Cheques], [Measures].[Titulos], [Measures].[Total]} ON COLUMNS,
  NON EMPTY {[Faixa Provisao PDD.Faixa Provisao].Levels(2).Members} ON ROWS
from [Operacoes de Credito]
where Crossjoin({[Produto].[Propria]}, {[Situacao do Pagamento].[Em aberto].[Em aberto   Vencido]})
]]></query> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>JavascriptRule</component-name>
        <action-type>JavaScript</action-type>
        <action-inputs> 
          <query_result type="result-set"/>  
          <callback type="string"/> 
        </action-inputs>
        <action-outputs> 
          <json type="string"/>  
          <rowCount type="integer"/> 
        </action-outputs>
        <component-definition> 
  <script><![CDATA[
QL = ''; 
DEBUG=false;

function formataJSON(v) {
var s = null;
if (v == null) {
s = 'null';
} else if (v instanceof java.lang.String) {
s = '"' + v + '"';
} else if (v instanceof java.util.Date) {
s = /*"new Date(" +*/ v.getTime() /*+ ")"*/;
} else if (v instanceof Array) {
s = new java.lang.StringBuilder("[ ");
for (var i=0; i<v.length; i++) {
if (i>0) {
s.append(',');
}
s.append(formataJSON(v[i]));
}
s.append(" ]");
} else {
s = v.toString();
}
if (DEBUG) {
 s = s.toString() + " /* " + v.getClass().getName() + " */";
}
return s.toString();
}

var rowCount=query_result.getRowCount();
var colCount=query_result.getColumnCount();
var json=new java.lang.StringBuilder('{ "result" : {');

var columnHeaders = new Array();
columnHeaders[0] = '"metrica"';
for (var col=0; col<colCount; col++) {
columnHeaders[col+1] = query_result.getMetaData().getColumnHeaders()[0][col];
}

json.append( 
'"metadata": { ' +
'"columns": ' + formataJSON(columnHeaders) + ', ' + QL +
'"rows": ' + rowCount + ', ' + QL +
'"cols": ' + (colCount+1) + QL +
' },' + QL);


json.append('"data" : [ ');
var rowData = null;
while (rowData = query_result.nextFlattened()) {
json.append(QL).append(formataJSON(rowData));
json.append(',');
}
json.deleteCharAt(json.length()-1); 

json.append(QL + '] ' + QL);

json.append('}' + QL + '}');

if (callback !== '' || callback === null) {
json = callback + '(' + json.toString() + ')'
} else {
json = json.toString();
}]]></script> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>TemplateComponent</component-name>
        <action-type>Message Template</action-type>
        <action-inputs> 
          <json type="string"/> 
        </action-inputs>
        <action-outputs> 
          <output-message type="string" mapping="out"/> 
        </action-outputs>
        <component-definition> 
          <template><![CDATA[{json}]]></template> 
        </component-definition> 
      </action-definition>
 
    </actions>


<!-- ***************************Top10Cedentes*************** -->  
    <actions> 
      <condition><![CDATA[getData == "Top10Cedentes"]]></condition>  
      <action-definition> 
        <component-name>MDXLookupRule</component-name>
        <action-type>OLAP</action-type>
        <action-inputs> 
          <Ano type="string"/> 
        </action-inputs>
        <action-resources> 
          <catalog mapping="catalog"/> 
        </action-resources>
        <action-outputs> 
          <query-results type="result-set" mapping="query_result"/> 
        </action-outputs>
        <component-definition> 
          <jndi><![CDATA[dw_wba_fi]]></jndi>  
          <catalog>Operacoes de Credito</catalog>   
          <query><![CDATA[
with member [Measures].[Valor Total] as 'Sum({Ancestor([Cedente].CurrentMember, 1.0)}, [Measures].[Valor do Titulo])'
  member [Measures].[%] as '([Measures].[Valor do Titulo] / [Measures].[Valor Total])', format_string = "#0.00%"
  member [Measures].[Total Top 10] as 'Sum(TopCount(Order({[Cedente].[Total].Children}, [Measures].[Valor do Titulo], DESC), 10.0), [Measures].[Valor do Titulo])'
  member [Measures].[% Top 10] as 'Sum(TopCount(Order({[Cedente].[Total].Children}, [Measures].[Valor do Titulo], DESC), 10.0), [Measures].[%])', format_string = "#0.00%"
select NON EMPTY {[Measures].[Valor do Titulo], [Measures].[%], [Measures].[Total Top 10], [Measures].[% Top 10]} ON COLUMNS,
  NON EMPTY Union({[Cedente].[Total]}, TopCount(Order({[Cedente].[Total].Children}, [Measures].[Valor do Titulo], DESC), 10.0)) ON ROWS
from [Operacoes de Credito]
where Crossjoin(Crossjoin({[Operacoes.Operacoes : Codigo].[Outros].[053], [Operacoes.Operacoes : Codigo].[Titulos].[040], [Operacoes.Operacoes : Codigo].[Titulos].[041], [Operacoes.Operacoes : Codigo].[Titulos].[046]}, {[Produto].[Propria]}), {[Situacao do Pagamento].[Em aberto]})

]]></query> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>JavascriptRule</component-name>
        <action-type>JavaScript</action-type>
        <action-inputs> 
          <query_result type="result-set"/>  
          <callback type="string"/> 
        </action-inputs>
        <action-outputs> 
          <json type="string"/>  
          <rowCount type="integer"/> 
        </action-outputs>
        <component-definition> 
  <script><![CDATA[
QL = ''; 
DEBUG=false;

function formataJSON(v) {
var s = null;
if (v == null) {
s = 'null';
} else if (v instanceof java.lang.String) {
s = '"' + v + '"';
} else if (v instanceof java.util.Date) {
s = /*"new Date(" +*/ v.getTime() /*+ ")"*/;
} else if (v instanceof Array) {
s = new java.lang.StringBuilder("[ ");
for (var i=0; i<v.length; i++) {
if (i>0) {
s.append(',');
}
s.append(formataJSON(v[i]));
}
s.append(" ]");
} else {
s = v.toString();
}
if (DEBUG) {
 s = s.toString() + " /* " + v.getClass().getName() + " */";
}
return s.toString();
}

var rowCount=query_result.getRowCount();
var colCount=query_result.getColumnCount();
var json=new java.lang.StringBuilder('{ "result" : {');

var columnHeaders = new Array();
columnHeaders[0] = '"metrica"';
for (var col=0; col<colCount; col++) {
columnHeaders[col+1] = query_result.getMetaData().getColumnHeaders()[0][col];
}

json.append( 
'"metadata": { ' +
'"columns": ' + formataJSON(columnHeaders) + ', ' + QL +
'"rows": ' + rowCount + ', ' + QL +
'"cols": ' + (colCount+1) + QL +
' },' + QL);


json.append('"data" : [ ');
var rowData = null;
while (rowData = query_result.nextFlattened()) {
json.append(QL).append(formataJSON(rowData));
json.append(',');
}
json.deleteCharAt(json.length()-1); 

json.append(QL + '] ' + QL);

json.append('}' + QL + '}');

if (callback !== '' || callback === null) {
json = callback + '(' + json.toString() + ')'
} else {
json = json.toString();
}]]></script> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>TemplateComponent</component-name>
        <action-type>Message Template</action-type>
        <action-inputs> 
          <json type="string"/> 
        </action-inputs>
        <action-outputs> 
          <output-message type="string" mapping="out"/> 
        </action-outputs>
        <component-definition> 
          <template><![CDATA[{json}]]></template> 
        </component-definition> 
      </action-definition>
 
    </actions>
  
<!-- ***************************Top10Sacados*************** -->  
    <actions> 
      <condition><![CDATA[getData == "Top10Sacados"]]></condition>  
      <action-definition> 
        <component-name>MDXLookupRule</component-name>
        <action-type>OLAP</action-type>
        <action-inputs> 
          <Ano type="string"/> 
        </action-inputs>
        <action-resources> 
          <catalog mapping="catalog"/> 
        </action-resources>
        <action-outputs> 
          <query-results type="result-set" mapping="query_result"/> 
        </action-outputs>
        <component-definition> 
          <jndi><![CDATA[dw_wba_fi]]></jndi>  
          <catalog>Operacoes de Credito</catalog>   
          <query><![CDATA[
with member [Measures].[Em Aberto] as 'Sum({[Situacao do Pagamento].[Em aberto]}, [Measures].[Valor do Titulo])'
  member [Measures].[Valor Total] as 'Sum({Ancestor([Sacado].CurrentMember, 1.0)}, [Measures].[Em Aberto])'
  member [Measures].[%] as '([Measures].[Em Aberto] / [Measures].[Valor Total])', format_string = "#0.00%"
  member [Measures].[Total Top 10] as 'Sum(TopCount(Order({[Sacado].[Total].Children}, [Measures].[Em Aberto], DESC), 10.0), [Measures].[Em Aberto])'
  member [Measures].[% Top 10] as 'Sum(TopCount(Order({[Sacado].[Total].Children}, [Measures].[Em Aberto], DESC), 10.0), [Measures].[%])', format_string = "#0.00%"
  member [Measures].[A Vencer] as 'Sum({[Situacao do Pagamento].[Em aberto].[Em aberto   A Vencer]}, [Measures].[Valor do Titulo])'
  member [Measures].[Vencido] as 'Sum({[Situacao do Pagamento].[Em aberto].[Em aberto   Vencido]}, [Measures].[Valor do Titulo])'
select NON EMPTY {[Measures].[Em Aberto], [Measures].[%], [Measures].[A Vencer], [Measures].[Vencido], [Measures].[Total Top 10], [Measures].[% Top 10]} ON COLUMNS,
  NON EMPTY Union({[Sacado].[Total]}, TopCount(Order({[Sacado].[Total].Children}, [Measures].[Em Aberto], DESC), 10.0)) ON ROWS
from [Operacoes de Credito]
where Crossjoin({[Operacoes.Operacoes : Codigo].[Titulos].[040], [Operacoes.Operacoes : Codigo].[Titulos].[041], [Operacoes.Operacoes : Codigo].[Titulos].[046]}, {[Produto].[Propria]})
]]></query> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>JavascriptRule</component-name>
        <action-type>JavaScript</action-type>
        <action-inputs> 
          <query_result type="result-set"/>  
          <callback type="string"/> 
        </action-inputs>
        <action-outputs> 
          <json type="string"/>  
          <rowCount type="integer"/> 
        </action-outputs>
        <component-definition> 
  <script><![CDATA[
QL = ''; 
DEBUG=false;

function formataJSON(v) {
var s = null;
if (v == null) {
s = 'null';
} else if (v instanceof java.lang.String) {
s = '"' + v + '"';
} else if (v instanceof java.util.Date) {
s = /*"new Date(" +*/ v.getTime() /*+ ")"*/;
} else if (v instanceof Array) {
s = new java.lang.StringBuilder("[ ");
for (var i=0; i<v.length; i++) {
if (i>0) {
s.append(',');
}
s.append(formataJSON(v[i]));
}
s.append(" ]");
} else {
s = v.toString();
}
if (DEBUG) {
 s = s.toString() + " /* " + v.getClass().getName() + " */";
}
return s.toString();
}

var rowCount=query_result.getRowCount();
var colCount=query_result.getColumnCount();
var json=new java.lang.StringBuilder('{ "result" : {');

var columnHeaders = new Array();
columnHeaders[0] = '"metrica"';
for (var col=0; col<colCount; col++) {
columnHeaders[col+1] = query_result.getMetaData().getColumnHeaders()[0][col];
}

json.append( 
'"metadata": { ' +
'"columns": ' + formataJSON(columnHeaders) + ', ' + QL +
'"rows": ' + rowCount + ', ' + QL +
'"cols": ' + (colCount+1) + QL +
' },' + QL);


json.append('"data" : [ ');
var rowData = null;
while (rowData = query_result.nextFlattened()) {
json.append(QL).append(formataJSON(rowData));
json.append(',');
}
json.deleteCharAt(json.length()-1); 

json.append(QL + '] ' + QL);

json.append('}' + QL + '}');

if (callback !== '' || callback === null) {
json = callback + '(' + json.toString() + ')'
} else {
json = json.toString();
}]]></script> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>TemplateComponent</component-name>
        <action-type>Message Template</action-type>
        <action-inputs> 
          <json type="string"/> 
        </action-inputs>
        <action-outputs> 
          <output-message type="string" mapping="out"/> 
        </action-outputs>
        <component-definition> 
          <template><![CDATA[{json}]]></template> 
        </component-definition> 
      </action-definition>
 
    </actions>
  
  
  
  <!-- ***************************Regressado*************** -->  
    <actions> 
      <condition><![CDATA[getData == "Regressado"]]></condition>  
      <action-definition> 
        <component-name>MDXLookupRule</component-name>
        <action-type>OLAP</action-type>
        <action-inputs> 
          <Ano type="string"/> 
        </action-inputs>
        <action-resources> 
          <catalog mapping="catalog"/> 
        </action-resources>
        <action-outputs> 
          <query-results type="result-set" mapping="query_result"/> 
        </action-outputs>
        <component-definition> 
          <jndi><![CDATA[dw_wba_fi]]></jndi>  
          <catalog>Operacoes de Credito</catalog>   
          <query><![CDATA[

		  
		  select NON EMPTY {[Measures].[Qtde Sacado], [Measures].[Valor Inclusao], [Measures].[Qtde de Titulo]} ON COLUMNS,
  NON EMPTY TopCount(Order({[Cedente].[Total].Children}, [Measures].[Valor Inclusao], DESC), 10.0) ON ROWS
from [Operacoes de Credito]
where Crossjoin(Crossjoin(Crossjoin(Crossjoin({[Comportamento de Pagamento].[Regressado]}, {[Data Pagamento.AnoMes].[Dezembro-2016], [Data Pagamento.AnoMes].[Novembro-2016], [Data Pagamento.AnoMes].[Outubro-2016], [Data Pagamento.AnoMes].[Setembro-2016], [Data Pagamento.AnoMes].[Agosto-2016]}), {[Empresa].[CONSOLIDADO].[PRUDENT FUNDO DE INVESTIMENTO EM DIREITOS CREDITORIOS]}), {[Produto].[Propria]}), {[Situacao do Pagamento].[Liquidado]})



]]></query> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>JavascriptRule</component-name>
        <action-type>JavaScript</action-type>
        <action-inputs> 
          <query_result type="result-set"/>  
          <callback type="string"/> 
        </action-inputs>
        <action-outputs> 
          <json type="string"/>  
          <rowCount type="integer"/> 
        </action-outputs>
        <component-definition> 
  <script><![CDATA[
QL = ''; 
DEBUG=false;

function formataJSON(v) {
var s = null;
if (v == null) {
s = 'null';
} else if (v instanceof java.lang.String) {
s = '"' + v + '"';
} else if (v instanceof java.util.Date) {
s = /*"new Date(" +*/ v.getTime() /*+ ")"*/;
} else if (v instanceof Array) {
s = new java.lang.StringBuilder("[ ");
for (var i=0; i<v.length; i++) {
if (i>0) {
s.append(',');
}
s.append(formataJSON(v[i]));
}
s.append(" ]");
} else {
s = v.toString();
}
if (DEBUG) {
 s = s.toString() + " /* " + v.getClass().getName() + " */";
}
return s.toString();
}

var rowCount=query_result.getRowCount();
var colCount=query_result.getColumnCount();
var json=new java.lang.StringBuilder('{ "result" : {');

var columnHeaders = new Array();
columnHeaders[0] = '"metrica"';
for (var col=0; col<colCount; col++) {
columnHeaders[col+1] = query_result.getMetaData().getColumnHeaders()[0][col];
}

json.append( 
'"metadata": { ' +
'"columns": ' + formataJSON(columnHeaders) + ', ' + QL +
'"rows": ' + rowCount + ', ' + QL +
'"cols": ' + (colCount+1) + QL +
' },' + QL);


json.append('"data" : [ ');
var rowData = null;
while (rowData = query_result.nextFlattened()) {
json.append(QL).append(formataJSON(rowData));
json.append(',');
}
json.deleteCharAt(json.length()-1); 

json.append(QL + '] ' + QL);

json.append('}' + QL + '}');

if (callback !== '' || callback === null) {
json = callback + '(' + json.toString() + ')'
} else {
json = json.toString();
}]]></script> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>TemplateComponent</component-name>
        <action-type>Message Template</action-type>
        <action-inputs> 
          <json type="string"/> 
        </action-inputs>
        <action-outputs> 
          <output-message type="string" mapping="out"/> 
        </action-outputs>
        <component-definition> 
          <template><![CDATA[{json}]]></template> 
        </component-definition> 
      </action-definition>
 
    </actions>
  
 
 <!-- ***************************TicketMedio*************** -->  
    <actions> 
      <condition><![CDATA[getData == "TicketMedio"]]></condition>  
      <action-definition> 
        <component-name>MDXLookupRule</component-name>
        <action-type>OLAP</action-type>
        <action-inputs> 
          <Ano type="string"/> 
        </action-inputs>
        <action-resources> 
          <catalog mapping="catalog"/> 
        </action-resources>
        <action-outputs> 
          <query-results type="result-set" mapping="query_result"/> 
        </action-outputs>
        <component-definition> 
          <jndi><![CDATA[dw_wba_fi]]></jndi>  
          <catalog>Operacoes de Credito</catalog>   
          <query><![CDATA[

		  
		  with member [Measures].[Valor do Titulos] as '[Measures].[Valor do Titulo]'
  member [Measures].[Qtde de Titulos] as '[Measures].[Qtde de Titulo]'
  member [Measures].[Ticket Medio] as '([Measures].[Valor do Titulos] / [Measures].[Qtde de Titulos])'
select NON EMPTY {[Measures].[Valor do Titulos], [Measures].[Qtde de Titulos], [Measures].[Ticket Medio], [Measures].[Prazo Medio]} ON COLUMNS,
  NON EMPTY {Hierarchize({{[Data Inc Contabil.AnoMesDia].[2016]}, Filter({{[Data Inc Contabil.AnoMesDia].[Mes].Members}}, (Exists({Ancestor([Data Inc Contabil.AnoMesDia].CurrentMember, [Data Inc Contabil.AnoMesDia].[Ano])}, {[Data Inc Contabil.AnoMesDia].[2016]}).Count > 0))})} ON ROWS
from [Operacoes de Credito]
where {[Situacao do Pagamento].[Liquidado]}




]]></query> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>JavascriptRule</component-name>
        <action-type>JavaScript</action-type>
        <action-inputs> 
          <query_result type="result-set"/>  
          <callback type="string"/> 
        </action-inputs>
        <action-outputs> 
          <json type="string"/>  
          <rowCount type="integer"/> 
        </action-outputs>
        <component-definition> 
  <script><![CDATA[
QL = ''; 
DEBUG=false;

function formataJSON(v) {
var s = null;
if (v == null) {
s = 'null';
} else if (v instanceof java.lang.String) {
s = '"' + v + '"';
} else if (v instanceof java.util.Date) {
s = /*"new Date(" +*/ v.getTime() /*+ ")"*/;
} else if (v instanceof Array) {
s = new java.lang.StringBuilder("[ ");
for (var i=0; i<v.length; i++) {
if (i>0) {
s.append(',');
}
s.append(formataJSON(v[i]));
}
s.append(" ]");
} else {
s = v.toString();
}
if (DEBUG) {
 s = s.toString() + " /* " + v.getClass().getName() + " */";
}
return s.toString();
}

var rowCount=query_result.getRowCount();
var colCount=query_result.getColumnCount();
var json=new java.lang.StringBuilder('{ "result" : {');

var columnHeaders = new Array();
columnHeaders[0] = '"metrica"';
for (var col=0; col<colCount; col++) {
columnHeaders[col+1] = query_result.getMetaData().getColumnHeaders()[0][col];
}

json.append( 
'"metadata": { ' +
'"columns": ' + formataJSON(columnHeaders) + ', ' + QL +
'"rows": ' + rowCount + ', ' + QL +
'"cols": ' + (colCount+1) + QL +
' },' + QL);


json.append('"data" : [ ');
var rowData = null;
while (rowData = query_result.nextFlattened()) {
json.append(QL).append(formataJSON(rowData));
json.append(',');
}
json.deleteCharAt(json.length()-1); 

json.append(QL + '] ' + QL);

json.append('}' + QL + '}');

if (callback !== '' || callback === null) {
json = callback + '(' + json.toString() + ')'
} else {
json = json.toString();
}]]></script> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>TemplateComponent</component-name>
        <action-type>Message Template</action-type>
        <action-inputs> 
          <json type="string"/> 
        </action-inputs>
        <action-outputs> 
          <output-message type="string" mapping="out"/> 
        </action-outputs>
        <component-definition> 
          <template><![CDATA[{json}]]></template> 
        </component-definition> 
      </action-definition>
 
    </actions>
  
  
  
   
 <!-- ***************************Prazo*************** -->  
    <actions> 
      <condition><![CDATA[getData == "Prazo"]]></condition>  
      <action-definition> 
        <component-name>MDXLookupRule</component-name>
        <action-type>OLAP</action-type>
        <action-inputs> 
          <Ano type="string"/> 
        </action-inputs>
        <action-resources> 
          <catalog mapping="catalog"/> 
        </action-resources>
        <action-outputs> 
          <query-results type="result-set" mapping="query_result"/> 
        </action-outputs>
        <component-definition> 
          <jndi><![CDATA[dw_wba_fi]]></jndi>  
          <catalog>Operacoes de Credito</catalog>   
          <query><![CDATA[
SELECT
NON EMPTY {[Measures].[Prazo Medio]} ON COLUMNS,
NON EMPTY {Hierarchize({{[Data Inc Contabil.AnoMesDia].[2016]}, Filter({{[Data Inc Contabil.AnoMesDia].[Mes].Members}}, (Exists(Ancestor([Data Inc Contabil.AnoMesDia].CurrentMember, [Data Inc Contabil.AnoMesDia].[Ano]), {[Data Inc Contabil.AnoMesDia].[2016]}).Count  > 0))})} ON ROWS
FROM [Operacoes de Credito]
WHERE {[Situacao do Pagamento].[Liquidado]}




]]></query> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>JavascriptRule</component-name>
        <action-type>JavaScript</action-type>
        <action-inputs> 
          <query_result type="result-set"/>  
          <callback type="string"/> 
        </action-inputs>
        <action-outputs> 
          <json type="string"/>  
          <rowCount type="integer"/> 
        </action-outputs>
        <component-definition> 
  <script><![CDATA[
QL = ''; 
DEBUG=false;

function formataJSON(v) {
var s = null;
if (v == null) {
s = 'null';
} else if (v instanceof java.lang.String) {
s = '"' + v + '"';
} else if (v instanceof java.util.Date) {
s = /*"new Date(" +*/ v.getTime() /*+ ")"*/;
} else if (v instanceof Array) {
s = new java.lang.StringBuilder("[ ");
for (var i=0; i<v.length; i++) {
if (i>0) {
s.append(',');
}
s.append(formataJSON(v[i]));
}
s.append(" ]");
} else {
s = v.toString();
}
if (DEBUG) {
 s = s.toString() + " /* " + v.getClass().getName() + " */";
}
return s.toString();
}

var rowCount=query_result.getRowCount();
var colCount=query_result.getColumnCount();
var json=new java.lang.StringBuilder('{ "result" : {');

var columnHeaders = new Array();
columnHeaders[0] = '"metrica"';
for (var col=0; col<colCount; col++) {
columnHeaders[col+1] = query_result.getMetaData().getColumnHeaders()[0][col];
}

json.append( 
'"metadata": { ' +
'"columns": ' + formataJSON(columnHeaders) + ', ' + QL +
'"rows": ' + rowCount + ', ' + QL +
'"cols": ' + (colCount+1) + QL +
' },' + QL);


json.append('"data" : [ ');
var rowData = null;
while (rowData = query_result.nextFlattened()) {
json.append(QL).append(formataJSON(rowData));
json.append(',');
}
json.deleteCharAt(json.length()-1); 

json.append(QL + '] ' + QL);

json.append('}' + QL + '}');

if (callback !== '' || callback === null) {
json = callback + '(' + json.toString() + ')'
} else {
json = json.toString();
}]]></script> 
        </component-definition> 
      </action-definition>
  
      <action-definition> 
        <component-name>TemplateComponent</component-name>
        <action-type>Message Template</action-type>
        <action-inputs> 
          <json type="string"/> 
        </action-inputs>
        <action-outputs> 
          <output-message type="string" mapping="out"/> 
        </action-outputs>
        <component-definition> 
          <template><![CDATA[{json}]]></template> 
        </component-definition> 
      </action-definition>
 
    </actions>
  
  
  
  
  
  
  
  </actions> 
</action-sequence>